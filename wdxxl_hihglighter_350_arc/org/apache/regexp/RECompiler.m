//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:wdxxl_lucene_350_highlighter.jar!org/apache/regexp/RECompiler.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Character.h"
#include "java/lang/Error.h"
#include "java/lang/Integer.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/System.h"
#include "java/util/Hashtable.h"
#include "org/apache/regexp/RE.h"
#include "org/apache/regexp/RECompiler.h"
#include "org/apache/regexp/REProgram.h"
#include "org/apache/regexp/RESyntaxException.h"

J2OBJC_INITIALIZED_DEFN(OrgApacheRegexpRECompiler)

JavaUtilHashtable *OrgApacheRegexpRECompiler_hashPOSIX;

@implementation OrgApacheRegexpRECompiler

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OrgApacheRegexpRECompiler_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)ensureWithInt:(jint)n {
  jint curlen = ((IOSCharArray *) nil_chk(instruction_))->size_;
  if (lenInstruction_ + n >= curlen) {
    while (lenInstruction_ + n >= curlen) {
      curlen *= 2;
    }
    IOSCharArray *newInstruction = [IOSCharArray newArrayWithLength:curlen];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(instruction_, 0, newInstruction, 0, lenInstruction_);
    instruction_ = newInstruction;
  }
}

- (void)emitWithChar:(jchar)c {
  [self ensureWithInt:1];
  *IOSCharArray_GetRef(nil_chk(instruction_), lenInstruction_++) = c;
}

- (void)nodeInsertWithChar:(jchar)opcode
                   withInt:(jint)opdata
                   withInt:(jint)insertAt {
  [self ensureWithInt:OrgApacheRegexpRE_nodeSize];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(instruction_, insertAt, instruction_, insertAt + OrgApacheRegexpRE_nodeSize, lenInstruction_ - insertAt);
  *IOSCharArray_GetRef(nil_chk(instruction_), insertAt + OrgApacheRegexpRE_offsetOpcode) = opcode;
  *IOSCharArray_GetRef(instruction_, insertAt + OrgApacheRegexpRE_offsetOpdata) = (jchar) opdata;
  *IOSCharArray_GetRef(instruction_, insertAt + OrgApacheRegexpRE_offsetNext) = 0;
  lenInstruction_ += OrgApacheRegexpRE_nodeSize;
}

- (void)setNextOfEndWithInt:(jint)node
                    withInt:(jint)pointTo {
  jint next = IOSCharArray_Get(nil_chk(instruction_), node + OrgApacheRegexpRE_offsetNext);
  while (next != 0 && node < lenInstruction_) {
    if (node == pointTo) {
      pointTo = lenInstruction_;
    }
    node += next;
    next = IOSCharArray_Get(instruction_, node + OrgApacheRegexpRE_offsetNext);
  }
  if (node < lenInstruction_) {
    *IOSCharArray_GetRef(instruction_, node + OrgApacheRegexpRE_offsetNext) = (jchar) (jshort) (pointTo - node);
  }
}

- (jint)nodeWithChar:(jchar)opcode
             withInt:(jint)opdata {
  [self ensureWithInt:OrgApacheRegexpRE_nodeSize];
  *IOSCharArray_GetRef(nil_chk(instruction_), lenInstruction_ + OrgApacheRegexpRE_offsetOpcode) = opcode;
  *IOSCharArray_GetRef(instruction_, lenInstruction_ + OrgApacheRegexpRE_offsetOpdata) = (jchar) opdata;
  *IOSCharArray_GetRef(instruction_, lenInstruction_ + OrgApacheRegexpRE_offsetNext) = 0;
  lenInstruction_ += OrgApacheRegexpRE_nodeSize;
  return lenInstruction_ - OrgApacheRegexpRE_nodeSize;
}

- (void)internalError {
  @throw new_JavaLangError_initWithNSString_(@"Internal error!");
}

- (void)syntaxErrorWithNSString:(NSString *)s {
  @throw new_OrgApacheRegexpRESyntaxException_initWithNSString_(s);
}

- (void)allocBrackets {
  if (bracketStart_ == nil) {
    bracketStart_ = [IOSIntArray newArrayWithLength:maxBrackets_];
    bracketEnd_ = [IOSIntArray newArrayWithLength:maxBrackets_];
    bracketMin_ = [IOSIntArray newArrayWithLength:maxBrackets_];
    bracketOpt_ = [IOSIntArray newArrayWithLength:maxBrackets_];
    for (jint i = 0; i < maxBrackets_; i++) {
      *IOSIntArray_GetRef(bracketStart_, i) = *IOSIntArray_GetRef(bracketEnd_, i) = *IOSIntArray_GetRef(bracketMin_, i) = *IOSIntArray_GetRef(bracketOpt_, i) = -1;
    }
  }
}

- (void)reallocBrackets {
  @synchronized(self) {
    if (bracketStart_ == nil) {
      [self allocBrackets];
    }
    jint new_size = maxBrackets_ * 2;
    IOSIntArray *new_bS = [IOSIntArray newArrayWithLength:new_size];
    IOSIntArray *new_bE = [IOSIntArray newArrayWithLength:new_size];
    IOSIntArray *new_bM = [IOSIntArray newArrayWithLength:new_size];
    IOSIntArray *new_bO = [IOSIntArray newArrayWithLength:new_size];
    for (jint i = brackets_; i < new_size; i++) {
      *IOSIntArray_GetRef(new_bS, i) = *IOSIntArray_GetRef(new_bE, i) = *IOSIntArray_GetRef(new_bM, i) = *IOSIntArray_GetRef(new_bO, i) = -1;
    }
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bracketStart_, 0, new_bS, 0, brackets_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bracketEnd_, 0, new_bE, 0, brackets_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bracketMin_, 0, new_bM, 0, brackets_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bracketOpt_, 0, new_bO, 0, brackets_);
    bracketStart_ = new_bS;
    bracketEnd_ = new_bE;
    bracketMin_ = new_bM;
    bracketOpt_ = new_bO;
    maxBrackets_ = new_size;
  }
}

- (void)bracket {
  if (idx_ >= len_ || [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++] != '{') {
    [self internalError];
  }
  if (idx_ >= len_ || !JavaLangCharacter_isDigitWithChar_([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_])) {
    [self syntaxErrorWithNSString:@"Expected digit"];
  }
  JavaLangStringBuffer *number = new_JavaLangStringBuffer_init();
  while (idx_ < len_ && JavaLangCharacter_isDigitWithChar_([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_])) {
    (void) [number appendWithChar:[((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++]];
  }
  @try {
    *IOSIntArray_GetRef(nil_chk(bracketMin_), brackets_) = JavaLangInteger_parseIntWithNSString_([number description]);
  }
  @catch (JavaLangNumberFormatException *e) {
    [self syntaxErrorWithNSString:@"Expected valid number"];
  }
  if (idx_ >= len_) {
    [self syntaxErrorWithNSString:@"Expected comma or right bracket"];
  }
  if ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == '}') {
    idx_++;
    *IOSIntArray_GetRef(nil_chk(bracketOpt_), brackets_) = 0;
    return;
  }
  if (idx_ >= len_ || [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++] != ',') {
    [self syntaxErrorWithNSString:@"Expected comma"];
  }
  if (idx_ >= len_) {
    [self syntaxErrorWithNSString:@"Expected comma or right bracket"];
  }
  if ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == '}') {
    idx_++;
    *IOSIntArray_GetRef(nil_chk(bracketOpt_), brackets_) = OrgApacheRegexpRECompiler_bracketUnbounded;
    return;
  }
  if (idx_ >= len_ || !JavaLangCharacter_isDigitWithChar_([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_])) {
    [self syntaxErrorWithNSString:@"Expected digit"];
  }
  [number setLengthWithInt:0];
  while (idx_ < len_ && JavaLangCharacter_isDigitWithChar_([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_])) {
    (void) [number appendWithChar:[((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++]];
  }
  @try {
    *IOSIntArray_GetRef(nil_chk(bracketOpt_), brackets_) = JavaLangInteger_parseIntWithNSString_([number description]) - IOSIntArray_Get(nil_chk(bracketMin_), brackets_);
  }
  @catch (JavaLangNumberFormatException *e) {
    [self syntaxErrorWithNSString:@"Expected valid number"];
  }
  if (IOSIntArray_Get(nil_chk(bracketOpt_), brackets_) < 0) {
    [self syntaxErrorWithNSString:@"Bad range"];
  }
  if (idx_ >= len_ || [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++] != '}') {
    [self syntaxErrorWithNSString:@"Missing close brace"];
  }
}

- (jint)escape {
  if ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] != '\\') {
    [self internalError];
  }
  if (idx_ + 1 == len_) {
    [self syntaxErrorWithNSString:@"Escape terminates string"];
  }
  idx_ += 2;
  jchar escapeChar = [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ - 1];
  switch (escapeChar) {
    case OrgApacheRegexpRE_E_BOUND:
    case OrgApacheRegexpRE_E_NBOUND:
    return OrgApacheRegexpRECompiler_ESC_COMPLEX;
    case OrgApacheRegexpRE_E_ALNUM:
    case OrgApacheRegexpRE_E_NALNUM:
    case OrgApacheRegexpRE_E_SPACE:
    case OrgApacheRegexpRE_E_NSPACE:
    case OrgApacheRegexpRE_E_DIGIT:
    case OrgApacheRegexpRE_E_NDIGIT:
    return OrgApacheRegexpRECompiler_ESC_CLASS;
    case 'u':
    case 'x':
    {
      jint hexDigits = (escapeChar == 'u' ? 4 : 2);
      jint val = 0;
      for (; idx_ < len_ && hexDigits-- > 0; idx_++) {
        jchar c = [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_];
        if (c >= '0' && c <= '9') {
          val = (JreLShift32(val, 4)) + c - '0';
        }
        else {
          c = JavaLangCharacter_toLowerCaseWithChar_(c);
          if (c >= 'a' && c <= 'f') {
            val = (JreLShift32(val, 4)) + (c - 'a') + 10;
          }
          else {
            [self syntaxErrorWithNSString:JreStrcat("$I$C", @"Expected ", hexDigits, @" hexadecimal digits after \\", escapeChar)];
          }
        }
      }
      return val;
    }
    case 't':
    return 0x0009;
    case 'n':
    return 0x000a;
    case 'r':
    return 0x000d;
    case 'f':
    return 0x000c;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    if ((idx_ < len_ && JavaLangCharacter_isDigitWithChar_([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_])) || escapeChar == '0') {
      jint val = escapeChar - '0';
      if (idx_ < len_ && JavaLangCharacter_isDigitWithChar_([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_])) {
        val = ((JreLShift32(val, 3)) + ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++] - '0'));
        if (idx_ < len_ && JavaLangCharacter_isDigitWithChar_([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_])) {
          val = ((JreLShift32(val, 3)) + ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++] - '0'));
        }
      }
      return val;
    }
    return OrgApacheRegexpRECompiler_ESC_BACKREF;
    default:
    return escapeChar;
  }
}

- (jint)characterClass {
  if ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] != '[') {
    [self internalError];
  }
  if ((idx_ + 1) >= len_ || [((NSString *) nil_chk(pattern_)) charAtWithInt:++idx_] == ']') {
    [self syntaxErrorWithNSString:@"Empty or unterminated class"];
  }
  if (idx_ < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == ':') {
    idx_++;
    jint idxStart = idx_;
    while (idx_ < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] >= 'a' && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] <= 'z') {
      idx_++;
    }
    if ((idx_ + 1) < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == ':' && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ + 1] == ']') {
      NSString *charClass = [((NSString *) nil_chk(pattern_)) java_substring:idxStart endIndex:idx_];
      JavaLangCharacter *i = (JavaLangCharacter *) cast_chk([((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) getWithId:charClass], [JavaLangCharacter class]);
      if (i != nil) {
        idx_ += 2;
        return [self nodeWithChar:OrgApacheRegexpRE_OP_POSIXCLASS withInt:[i charValue]];
      }
      [self syntaxErrorWithNSString:JreStrcat("$$C", @"Invalid POSIX character class '", charClass, '\'')];
    }
    [self syntaxErrorWithNSString:@"Invalid POSIX character class syntax"];
  }
  jint ret = [self nodeWithChar:OrgApacheRegexpRE_OP_ANYOF withInt:0];
  jchar CHAR_INVALID = JavaLangCharacter_MAX_VALUE;
  jchar last = CHAR_INVALID;
  jchar simpleChar = 0;
  jboolean include = true;
  jboolean definingRange = false;
  jint idxFirst = idx_;
  jchar rangeStart = JavaLangCharacter_MIN_VALUE;
  jchar rangeEnd;
  OrgApacheRegexpRECompiler_RERange *range = new_OrgApacheRegexpRECompiler_RERange_initWithOrgApacheRegexpRECompiler_(self);
  while (idx_ < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] != ']') {
    switch ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_]) {
      case '^':
      include = !include;
      if (idx_ == idxFirst) {
        [range includeWithInt:JavaLangCharacter_MIN_VALUE withInt:JavaLangCharacter_MAX_VALUE withBoolean:true];
      }
      idx_++;
      continue;
      case '\\':
      {
        jint c;
        switch (c = [self escape]) {
          case OrgApacheRegexpRECompiler_ESC_COMPLEX:
          case OrgApacheRegexpRECompiler_ESC_BACKREF:
          [self syntaxErrorWithNSString:@"Bad character class"];
          case OrgApacheRegexpRECompiler_ESC_CLASS:
          if (definingRange) {
            [self syntaxErrorWithNSString:@"Bad character class"];
          }
          switch ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ - 1]) {
            case OrgApacheRegexpRE_E_NSPACE:
            [range includeWithInt:JavaLangCharacter_MIN_VALUE withInt:7 withBoolean:include];
            [range includeWithChar:(jchar) 11 withBoolean:include];
            [range includeWithInt:14 withInt:31 withBoolean:include];
            [range includeWithInt:33 withInt:JavaLangCharacter_MAX_VALUE withBoolean:include];
            break;
            case OrgApacheRegexpRE_E_NALNUM:
            [range includeWithInt:JavaLangCharacter_MIN_VALUE withInt:'/' withBoolean:include];
            [range includeWithInt:':' withInt:'@' withBoolean:include];
            [range includeWithInt:'[' withInt:'^' withBoolean:include];
            [range includeWithChar:'`' withBoolean:include];
            [range includeWithInt:'{' withInt:JavaLangCharacter_MAX_VALUE withBoolean:include];
            break;
            case OrgApacheRegexpRE_E_NDIGIT:
            [range includeWithInt:JavaLangCharacter_MIN_VALUE withInt:'/' withBoolean:include];
            [range includeWithInt:':' withInt:JavaLangCharacter_MAX_VALUE withBoolean:include];
            break;
            case OrgApacheRegexpRE_E_SPACE:
            [range includeWithChar:0x0009 withBoolean:include];
            [range includeWithChar:0x000d withBoolean:include];
            [range includeWithChar:0x000c withBoolean:include];
            [range includeWithChar:0x000a withBoolean:include];
            [range includeWithChar:0x0008 withBoolean:include];
            [range includeWithChar:' ' withBoolean:include];
            break;
            case OrgApacheRegexpRE_E_ALNUM:
            [range includeWithInt:'a' withInt:'z' withBoolean:include];
            [range includeWithInt:'A' withInt:'Z' withBoolean:include];
            [range includeWithChar:'_' withBoolean:include];
            case OrgApacheRegexpRE_E_DIGIT:
            [range includeWithInt:'0' withInt:'9' withBoolean:include];
            break;
          }
          last = CHAR_INVALID;
          break;
          default:
          simpleChar = (jchar) c;
          goto break_switchOnCharacter;
        }
      }
      continue;
      case '-':
      if (definingRange) {
        [self syntaxErrorWithNSString:@"Bad class range"];
      }
      definingRange = true;
      rangeStart = (last == CHAR_INVALID ? 0 : last);
      if ((idx_ + 1) < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:++idx_] == ']') {
        simpleChar = JavaLangCharacter_MAX_VALUE;
        break;
      }
      continue;
      default:
      simpleChar = [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++];
      break;
    }
    break_switchOnCharacter: ;
    if (definingRange) {
      rangeEnd = simpleChar;
      if (rangeStart >= rangeEnd) {
        [self syntaxErrorWithNSString:@"Bad character class"];
      }
      [range includeWithInt:rangeStart withInt:rangeEnd withBoolean:include];
      last = CHAR_INVALID;
      definingRange = false;
    }
    else {
      if (idx_ >= len_ || [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] != '-') {
        [range includeWithChar:simpleChar withBoolean:include];
      }
      last = simpleChar;
    }
  }
  if (idx_ == len_) {
    [self syntaxErrorWithNSString:@"Unterminated character class"];
  }
  idx_++;
  *IOSCharArray_GetRef(nil_chk(instruction_), ret + OrgApacheRegexpRE_offsetOpdata) = (jchar) range->num_;
  for (jint i = 0; i < range->num_; i++) {
    [self emitWithChar:(jchar) IOSIntArray_Get(nil_chk(range->minRange_), i)];
    [self emitWithChar:(jchar) IOSIntArray_Get(nil_chk(range->maxRange_), i)];
  }
  return ret;
}

- (jint)atom {
  jint ret = [self nodeWithChar:OrgApacheRegexpRE_OP_ATOM withInt:0];
  jint lenAtom = 0;
  while (idx_ < len_) {
    if ((idx_ + 1) < len_) {
      jchar c = [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ + 1];
      if ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == '\\') {
        jint idxEscape = idx_;
        [self escape];
        if (idx_ < len_) {
          c = [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_];
        }
        idx_ = idxEscape;
      }
      switch (c) {
        case '{':
        case '?':
        case '*':
        case '+':
        if (lenAtom != 0) {
          goto break_atomLoop;
        }
      }
    }
    switch ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_]) {
      case ']':
      case '^':
      case '$':
      case '.':
      case '[':
      case '(':
      case ')':
      case '|':
      goto break_atomLoop;
      case '{':
      case '?':
      case '*':
      case '+':
      if (lenAtom == 0) {
        [self syntaxErrorWithNSString:@"Missing operand to closure"];
      }
      goto break_atomLoop;
      case '\\':
      {
        jint idxBeforeEscape = idx_;
        jint c = [self escape];
        if ((c & OrgApacheRegexpRECompiler_ESC_MASK) == OrgApacheRegexpRECompiler_ESC_MASK) {
          idx_ = idxBeforeEscape;
          goto break_atomLoop;
        }
        [self emitWithChar:(jchar) c];
        lenAtom++;
      }
      break;
      default:
      [self emitWithChar:[((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++]];
      lenAtom++;
      break;
    }
  }
  break_atomLoop: ;
  if (lenAtom == 0) {
    [self internalError];
  }
  *IOSCharArray_GetRef(nil_chk(instruction_), ret + OrgApacheRegexpRE_offsetOpdata) = (jchar) lenAtom;
  return ret;
}

- (jint)terminalWithIntArray:(IOSIntArray *)flags {
  switch ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_]) {
    case OrgApacheRegexpRE_OP_EOL:
    case OrgApacheRegexpRE_OP_BOL:
    case OrgApacheRegexpRE_OP_ANY:
    return [self nodeWithChar:[((NSString *) nil_chk(pattern_)) charAtWithInt:idx_++] withInt:0];
    case '[':
    return [self characterClass];
    case '(':
    return [self exprWithIntArray:flags];
    case ')':
    [self syntaxErrorWithNSString:@"Unexpected close paren"];
    case '|':
    [self internalError];
    case ']':
    [self syntaxErrorWithNSString:@"Mismatched class"];
    case 0:
    [self syntaxErrorWithNSString:@"Unexpected end of input"];
    case '?':
    case '+':
    case '{':
    case '*':
    [self syntaxErrorWithNSString:@"Missing operand to closure"];
    case '\\':
    {
      jint idxBeforeEscape = idx_;
      switch ([self escape]) {
        case OrgApacheRegexpRECompiler_ESC_CLASS:
        case OrgApacheRegexpRECompiler_ESC_COMPLEX:
        *IOSIntArray_GetRef(nil_chk(flags), 0) &= ~OrgApacheRegexpRECompiler_NODE_NULLABLE;
        return [self nodeWithChar:OrgApacheRegexpRE_OP_ESCAPE withInt:[((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ - 1]];
        case OrgApacheRegexpRECompiler_ESC_BACKREF:
        {
          jchar backreference = (jchar) ([((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ - 1] - '0');
          if (parens_ <= backreference) {
            [self syntaxErrorWithNSString:@"Bad backreference"];
          }
          *IOSIntArray_GetRef(nil_chk(flags), 0) |= OrgApacheRegexpRECompiler_NODE_NULLABLE;
          return [self nodeWithChar:OrgApacheRegexpRE_OP_BACKREF withInt:backreference];
        }
        default:
        idx_ = idxBeforeEscape;
        *IOSIntArray_GetRef(nil_chk(flags), 0) &= ~OrgApacheRegexpRECompiler_NODE_NULLABLE;
        break;
      }
    }
  }
  *IOSIntArray_GetRef(nil_chk(flags), 0) &= ~OrgApacheRegexpRECompiler_NODE_NULLABLE;
  return [self atom];
}

- (jint)closureWithIntArray:(IOSIntArray *)flags {
  jint idxBeforeTerminal = idx_;
  IOSIntArray *terminalFlags = [IOSIntArray newArrayWithInts:(jint[]){ OrgApacheRegexpRECompiler_NODE_NORMAL } count:1];
  jint ret = [self terminalWithIntArray:terminalFlags];
  *IOSIntArray_GetRef(nil_chk(flags), 0) |= IOSIntArray_Get(terminalFlags, 0);
  if (idx_ >= len_) {
    return ret;
  }
  jboolean greedy = true;
  jchar closureType = [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_];
  {
    jint opcode;
    switch (closureType) {
      case '?':
      case '*':
      *IOSIntArray_GetRef(flags, 0) |= OrgApacheRegexpRECompiler_NODE_NULLABLE;
      case '+':
      idx_++;
      case '{':
      opcode = IOSCharArray_Get(nil_chk(instruction_), ret + OrgApacheRegexpRE_offsetOpcode);
      if (opcode == OrgApacheRegexpRE_OP_BOL || opcode == OrgApacheRegexpRE_OP_EOL) {
        [self syntaxErrorWithNSString:@"Bad closure operand"];
      }
      if ((IOSIntArray_Get(terminalFlags, 0) & OrgApacheRegexpRECompiler_NODE_NULLABLE) != 0) {
        [self syntaxErrorWithNSString:@"Closure operand can't be nullable"];
      }
      break;
    }
  }
  if (idx_ < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == '?') {
    idx_++;
    greedy = false;
  }
  if (greedy) {
    switch (closureType) {
      case '{':
      {
        jboolean found = false;
        jint i;
        [self allocBrackets];
        for (i = 0; i < brackets_; i++) {
          if (IOSIntArray_Get(nil_chk(bracketStart_), i) == idx_) {
            found = true;
            break;
          }
        }
        if (!found) {
          if (brackets_ >= maxBrackets_) {
            [self reallocBrackets];
          }
          *IOSIntArray_GetRef(nil_chk(bracketStart_), brackets_) = idx_;
          [self bracket];
          *IOSIntArray_GetRef(nil_chk(bracketEnd_), brackets_) = idx_;
          i = brackets_++;
        }
        if ((*IOSIntArray_GetRef(nil_chk(bracketMin_), i))-- > 0) {
          if (IOSIntArray_Get(bracketMin_, i) > 0 || IOSIntArray_Get(nil_chk(bracketOpt_), i) != 0) {
            for (jint j = 0; j < brackets_; j++) {
              if (j != i && IOSIntArray_Get(nil_chk(bracketStart_), j) < idx_ && IOSIntArray_Get(bracketStart_, j) >= idxBeforeTerminal) {
                brackets_--;
                *IOSIntArray_GetRef(nil_chk(bracketStart_), j) = IOSIntArray_Get(bracketStart_, brackets_);
                *IOSIntArray_GetRef(nil_chk(bracketEnd_), j) = IOSIntArray_Get(bracketEnd_, brackets_);
                *IOSIntArray_GetRef(bracketMin_, j) = IOSIntArray_Get(bracketMin_, brackets_);
                *IOSIntArray_GetRef(nil_chk(bracketOpt_), j) = IOSIntArray_Get(bracketOpt_, brackets_);
              }
            }
            idx_ = idxBeforeTerminal;
          }
          else {
            idx_ = IOSIntArray_Get(nil_chk(bracketEnd_), i);
          }
          break;
        }
        if (IOSIntArray_Get(nil_chk(bracketOpt_), i) == OrgApacheRegexpRECompiler_bracketUnbounded) {
          closureType = '*';
          *IOSIntArray_GetRef(bracketOpt_, i) = 0;
          idx_ = IOSIntArray_Get(nil_chk(bracketEnd_), i);
        }
        else if ((*IOSIntArray_GetRef(bracketOpt_, i))-- > 0) {
          if (IOSIntArray_Get(bracketOpt_, i) > 0) {
            idx_ = idxBeforeTerminal;
          }
          else {
            idx_ = IOSIntArray_Get(nil_chk(bracketEnd_), i);
          }
          closureType = '?';
        }
        else {
          lenInstruction_ = ret;
          [self nodeWithChar:OrgApacheRegexpRE_OP_NOTHING withInt:0];
          idx_ = IOSIntArray_Get(nil_chk(bracketEnd_), i);
          break;
        }
      }
      case '?':
      case '*':
      if (!greedy) {
        break;
      }
      if (closureType == '?') {
        [self nodeInsertWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0 withInt:ret];
        [self setNextOfEndWithInt:ret withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0]];
        jint nothing = [self nodeWithChar:OrgApacheRegexpRE_OP_NOTHING withInt:0];
        [self setNextOfEndWithInt:ret withInt:nothing];
        [self setNextOfEndWithInt:ret + OrgApacheRegexpRE_nodeSize withInt:nothing];
      }
      if (closureType == '*') {
        [self nodeInsertWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0 withInt:ret];
        [self setNextOfEndWithInt:ret + OrgApacheRegexpRE_nodeSize withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0]];
        [self setNextOfEndWithInt:ret + OrgApacheRegexpRE_nodeSize withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_GOTO withInt:0]];
        [self setNextOfEndWithInt:ret + OrgApacheRegexpRE_nodeSize withInt:ret];
        [self setNextOfEndWithInt:ret withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0]];
        [self setNextOfEndWithInt:ret withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_NOTHING withInt:0]];
      }
      break;
      case '+':
      {
        jint branch;
        branch = [self nodeWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0];
        [self setNextOfEndWithInt:ret withInt:branch];
        [self setNextOfEndWithInt:[self nodeWithChar:OrgApacheRegexpRE_OP_GOTO withInt:0] withInt:ret];
        [self setNextOfEndWithInt:branch withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0]];
        [self setNextOfEndWithInt:ret withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_NOTHING withInt:0]];
      }
      break;
    }
  }
  else {
    [self setNextOfEndWithInt:ret withInt:[self nodeWithChar:OrgApacheRegexpRE_OP_END withInt:0]];
    switch (closureType) {
      case '?':
      [self nodeInsertWithChar:OrgApacheRegexpRE_OP_RELUCTANTMAYBE withInt:0 withInt:ret];
      break;
      case '*':
      [self nodeInsertWithChar:OrgApacheRegexpRE_OP_RELUCTANTSTAR withInt:0 withInt:ret];
      break;
      case '+':
      [self nodeInsertWithChar:OrgApacheRegexpRE_OP_RELUCTANTPLUS withInt:0 withInt:ret];
      break;
    }
    [self setNextOfEndWithInt:ret withInt:lenInstruction_];
  }
  return ret;
}

- (jint)branchWithIntArray:(IOSIntArray *)flags {
  jint node;
  jint ret = [self nodeWithChar:OrgApacheRegexpRE_OP_BRANCH withInt:0];
  jint chain = -1;
  IOSIntArray *closureFlags = [IOSIntArray newArrayWithLength:1];
  jboolean nullable = true;
  while (idx_ < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] != '|' && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] != ')') {
    *IOSIntArray_GetRef(closureFlags, 0) = OrgApacheRegexpRECompiler_NODE_NORMAL;
    node = [self closureWithIntArray:closureFlags];
    if (IOSIntArray_Get(closureFlags, 0) == OrgApacheRegexpRECompiler_NODE_NORMAL) {
      nullable = false;
    }
    if (chain != -1) {
      [self setNextOfEndWithInt:chain withInt:node];
    }
    chain = node;
  }
  if (chain == -1) {
    [self nodeWithChar:OrgApacheRegexpRE_OP_NOTHING withInt:0];
  }
  if (nullable) {
    *IOSIntArray_GetRef(nil_chk(flags), 0) |= OrgApacheRegexpRECompiler_NODE_NULLABLE;
  }
  return ret;
}

- (jint)exprWithIntArray:(IOSIntArray *)flags {
  jint paren = -1;
  jint ret = -1;
  jint closeParens = parens_;
  if ((IOSIntArray_Get(nil_chk(flags), 0) & OrgApacheRegexpRECompiler_NODE_TOPLEVEL) == 0 && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == '(') {
    if (idx_ + 2 < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ + 1] == '?' && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_ + 2] == ':') {
      paren = 2;
      idx_ += 3;
      ret = [self nodeWithChar:OrgApacheRegexpRE_OP_OPEN_CLUSTER withInt:0];
    }
    else {
      paren = 1;
      idx_++;
      ret = [self nodeWithChar:OrgApacheRegexpRE_OP_OPEN withInt:parens_++];
    }
  }
  *IOSIntArray_GetRef(flags, 0) &= ~OrgApacheRegexpRECompiler_NODE_TOPLEVEL;
  jint branch = [self branchWithIntArray:flags];
  if (ret == -1) {
    ret = branch;
  }
  else {
    [self setNextOfEndWithInt:ret withInt:branch];
  }
  while (idx_ < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == '|') {
    idx_++;
    branch = [self branchWithIntArray:flags];
    [self setNextOfEndWithInt:ret withInt:branch];
  }
  jint end;
  if (paren > 0) {
    if (idx_ < len_ && [((NSString *) nil_chk(pattern_)) charAtWithInt:idx_] == ')') {
      idx_++;
    }
    else {
      [self syntaxErrorWithNSString:@"Missing close paren"];
    }
    if (paren == 1) {
      end = [self nodeWithChar:OrgApacheRegexpRE_OP_CLOSE withInt:closeParens];
    }
    else {
      end = [self nodeWithChar:OrgApacheRegexpRE_OP_CLOSE_CLUSTER withInt:0];
    }
  }
  else {
    end = [self nodeWithChar:OrgApacheRegexpRE_OP_END withInt:0];
  }
  [self setNextOfEndWithInt:ret withInt:end];
  jint currentNode = ret;
  jint nextNodeOffset = IOSCharArray_Get(nil_chk(instruction_), currentNode + OrgApacheRegexpRE_offsetNext);
  while (nextNodeOffset != 0 && currentNode < lenInstruction_) {
    if (IOSCharArray_Get(instruction_, currentNode + OrgApacheRegexpRE_offsetOpcode) == OrgApacheRegexpRE_OP_BRANCH) {
      [self setNextOfEndWithInt:currentNode + OrgApacheRegexpRE_nodeSize withInt:end];
    }
    nextNodeOffset = IOSCharArray_Get(nil_chk(instruction_), currentNode + OrgApacheRegexpRE_offsetNext);
    currentNode += nextNodeOffset;
  }
  return ret;
}

- (OrgApacheRegexpREProgram *)compileWithNSString:(NSString *)pattern {
  self->pattern_ = pattern;
  len_ = [((NSString *) nil_chk(pattern)) java_length];
  idx_ = 0;
  lenInstruction_ = 0;
  parens_ = 1;
  brackets_ = 0;
  IOSIntArray *flags = [IOSIntArray newArrayWithInts:(jint[]){ OrgApacheRegexpRECompiler_NODE_TOPLEVEL } count:1];
  [self exprWithIntArray:flags];
  if (idx_ != len_) {
    if ([pattern charAtWithInt:idx_] == ')') {
      [self syntaxErrorWithNSString:@"Unmatched close paren"];
    }
    [self syntaxErrorWithNSString:@"Unexpected input remains"];
  }
  IOSCharArray *ins = [IOSCharArray newArrayWithLength:lenInstruction_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(instruction_, 0, ins, 0, lenInstruction_);
  return new_OrgApacheRegexpREProgram_initWithInt_withCharArray_(parens_, ins);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, 10, -1, -1, -1 },
    { NULL, "V", 0x0, 11, 12, 13, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x20, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, 13, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, 13, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, 13, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, 13, -1, -1, -1 },
    { NULL, "I", 0x0, 14, 15, 13, -1, -1, -1 },
    { NULL, "I", 0x0, 16, 15, 13, -1, -1, -1 },
    { NULL, "I", 0x0, 17, 15, 13, -1, -1, -1 },
    { NULL, "I", 0x0, 18, 15, 13, -1, -1, -1 },
    { NULL, "LOrgApacheRegexpREProgram;", 0x1, 19, 12, 13, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(ensureWithInt:);
  methods[2].selector = @selector(emitWithChar:);
  methods[3].selector = @selector(nodeInsertWithChar:withInt:withInt:);
  methods[4].selector = @selector(setNextOfEndWithInt:withInt:);
  methods[5].selector = @selector(nodeWithChar:withInt:);
  methods[6].selector = @selector(internalError);
  methods[7].selector = @selector(syntaxErrorWithNSString:);
  methods[8].selector = @selector(allocBrackets);
  methods[9].selector = @selector(reallocBrackets);
  methods[10].selector = @selector(bracket);
  methods[11].selector = @selector(escape);
  methods[12].selector = @selector(characterClass);
  methods[13].selector = @selector(atom);
  methods[14].selector = @selector(terminalWithIntArray:);
  methods[15].selector = @selector(closureWithIntArray:);
  methods[16].selector = @selector(branchWithIntArray:);
  methods[17].selector = @selector(exprWithIntArray:);
  methods[18].selector = @selector(compileWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "instruction_", "[C", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "lenInstruction_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "pattern_", "LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "len_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "idx_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "parens_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "NODE_NORMAL", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_NODE_NORMAL, 0x18, -1, -1, -1, -1 },
    { "NODE_NULLABLE", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_NODE_NULLABLE, 0x18, -1, -1, -1, -1 },
    { "NODE_TOPLEVEL", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_NODE_TOPLEVEL, 0x18, -1, -1, -1, -1 },
    { "ESC_MASK", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_ESC_MASK, 0x18, -1, -1, -1, -1 },
    { "ESC_BACKREF", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_ESC_BACKREF, 0x18, -1, -1, -1, -1 },
    { "ESC_COMPLEX", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_ESC_COMPLEX, 0x18, -1, -1, -1, -1 },
    { "ESC_CLASS", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_ESC_CLASS, 0x18, -1, -1, -1, -1 },
    { "maxBrackets_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "bracketUnbounded", "I", .constantValue.asInt = OrgApacheRegexpRECompiler_bracketUnbounded, 0x18, -1, -1, -1, -1 },
    { "brackets_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "bracketStart_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "bracketEnd_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "bracketMin_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "bracketOpt_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "hashPOSIX", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x8, -1, 20, -1, -1 },
  };
  static const void *ptrTable[] = { "ensure", "I", "emit", "C", "nodeInsert", "CII", "setNextOfEnd", "II", "node", "CI", "LJavaLangError;", "syntaxError", "LNSString;", "LOrgApacheRegexpRESyntaxException;", "terminal", "[I", "closure", "branch", "expr", "compile", &OrgApacheRegexpRECompiler_hashPOSIX, "LOrgApacheRegexpRECompiler_RERange;" };
  static const J2ObjcClassInfo _OrgApacheRegexpRECompiler = { "RECompiler", "org.apache.regexp", ptrTable, methods, fields, 7, 0x1, 19, 21, -1, 21, -1, -1, -1 };
  return &_OrgApacheRegexpRECompiler;
}

+ (void)initialize {
  if (self == [OrgApacheRegexpRECompiler class]) {
    OrgApacheRegexpRECompiler_hashPOSIX = new_JavaUtilHashtable_init();
    {
      (void) [OrgApacheRegexpRECompiler_hashPOSIX putWithId:@"alnum" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_ALNUM)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"alpha" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_ALPHA)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"blank" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_BLANK)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"cntrl" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_CNTRL)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"digit" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_DIGIT)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"graph" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_GRAPH)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"lower" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_LOWER)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"print" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_PRINT)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"punct" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_PUNCT)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"space" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_SPACE)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"upper" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_UPPER)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"xdigit" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_XDIGIT)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"javastart" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_JSTART)];
      (void) [((JavaUtilHashtable *) nil_chk(OrgApacheRegexpRECompiler_hashPOSIX)) putWithId:@"javapart" withId:new_JavaLangCharacter_initWithChar_(OrgApacheRegexpRE_POSIX_CLASS_JPART)];
    }
    J2OBJC_SET_INITIALIZED(OrgApacheRegexpRECompiler)
  }
}

@end

void OrgApacheRegexpRECompiler_init(OrgApacheRegexpRECompiler *self) {
  NSObject_init(self);
  self->maxBrackets_ = 10;
  self->brackets_ = 0;
  self->bracketStart_ = nil;
  self->bracketEnd_ = nil;
  self->bracketMin_ = nil;
  self->bracketOpt_ = nil;
  self->instruction_ = [IOSCharArray newArrayWithLength:128];
  self->lenInstruction_ = 0;
}

OrgApacheRegexpRECompiler *new_OrgApacheRegexpRECompiler_init() {
  J2OBJC_NEW_IMPL(OrgApacheRegexpRECompiler, init)
}

OrgApacheRegexpRECompiler *create_OrgApacheRegexpRECompiler_init() {
  J2OBJC_CREATE_IMPL(OrgApacheRegexpRECompiler, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheRegexpRECompiler)

@implementation OrgApacheRegexpRECompiler_RERange

- (instancetype)initWithOrgApacheRegexpRECompiler:(OrgApacheRegexpRECompiler *)outer$ {
  OrgApacheRegexpRECompiler_RERange_initWithOrgApacheRegexpRECompiler_(self, outer$);
  return self;
}

- (void)delete__WithInt:(jint)index {
  if (num_ == 0 || index >= num_) {
    return;
  }
  while (++index < num_) {
    if (index - 1 >= 0) {
      *IOSIntArray_GetRef(nil_chk(minRange_), index - 1) = IOSIntArray_Get(minRange_, index);
      *IOSIntArray_GetRef(nil_chk(maxRange_), index - 1) = IOSIntArray_Get(maxRange_, index);
    }
  }
  num_--;
}

- (void)mergeWithInt:(jint)min
             withInt:(jint)max {
  for (jint i = 0; i < num_; i++) {
    if (min >= IOSIntArray_Get(nil_chk(minRange_), i) && max <= IOSIntArray_Get(nil_chk(maxRange_), i)) {
      return;
    }
    else if (min <= IOSIntArray_Get(minRange_, i) && max >= IOSIntArray_Get(nil_chk(maxRange_), i)) {
      [self delete__WithInt:i];
      [self mergeWithInt:min withInt:max];
      return;
    }
    else if (min >= IOSIntArray_Get(minRange_, i) && min <= IOSIntArray_Get(nil_chk(maxRange_), i)) {
      min = IOSIntArray_Get(minRange_, i);
      [self delete__WithInt:i];
      [self mergeWithInt:min withInt:max];
      return;
    }
    else if (max >= IOSIntArray_Get(minRange_, i) && max <= IOSIntArray_Get(nil_chk(maxRange_), i)) {
      max = IOSIntArray_Get(nil_chk(maxRange_), i);
      [self delete__WithInt:i];
      [self mergeWithInt:min withInt:max];
      return;
    }
  }
  if (num_ >= size_) {
    size_ *= 2;
    IOSIntArray *newMin = [IOSIntArray newArrayWithLength:size_];
    IOSIntArray *newMax = [IOSIntArray newArrayWithLength:size_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(minRange_, 0, newMin, 0, num_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(maxRange_, 0, newMax, 0, num_);
    minRange_ = newMin;
    maxRange_ = newMax;
  }
  *IOSIntArray_GetRef(nil_chk(minRange_), num_) = min;
  *IOSIntArray_GetRef(nil_chk(maxRange_), num_) = max;
  num_++;
}

- (void)removeWithInt:(jint)min
              withInt:(jint)max {
  for (jint i = 0; i < num_; i++) {
    if (IOSIntArray_Get(nil_chk(minRange_), i) >= min && IOSIntArray_Get(nil_chk(maxRange_), i) <= max) {
      [self delete__WithInt:i];
      i--;
      return;
    }
    else if (min >= IOSIntArray_Get(minRange_, i) && max <= IOSIntArray_Get(nil_chk(maxRange_), i)) {
      jint minr = IOSIntArray_Get(minRange_, i);
      jint maxr = IOSIntArray_Get(nil_chk(maxRange_), i);
      [self delete__WithInt:i];
      if (minr < min) {
        [self mergeWithInt:minr withInt:min - 1];
      }
      if (max < maxr) {
        [self mergeWithInt:max + 1 withInt:maxr];
      }
      return;
    }
    else if (IOSIntArray_Get(minRange_, i) >= min && IOSIntArray_Get(minRange_, i) <= max) {
      *IOSIntArray_GetRef(minRange_, i) = max + 1;
      return;
    }
    else if (IOSIntArray_Get(nil_chk(maxRange_), i) >= min && IOSIntArray_Get(maxRange_, i) <= max) {
      *IOSIntArray_GetRef(maxRange_, i) = min - 1;
      return;
    }
  }
}

- (void)includeWithInt:(jint)min
               withInt:(jint)max
           withBoolean:(jboolean)include {
  if (include) {
    [self mergeWithInt:min withInt:max];
  }
  else {
    [self removeWithInt:min withInt:max];
  }
}

- (void)includeWithChar:(jchar)minmax
            withBoolean:(jboolean)include {
  [self includeWithInt:minmax withInt:minmax withBoolean:include];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 4, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 5, 7, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgApacheRegexpRECompiler:);
  methods[1].selector = @selector(delete__WithInt:);
  methods[2].selector = @selector(mergeWithInt:withInt:);
  methods[3].selector = @selector(removeWithInt:withInt:);
  methods[4].selector = @selector(includeWithInt:withInt:withBoolean:);
  methods[5].selector = @selector(includeWithChar:withBoolean:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "size_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "minRange_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "maxRange_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "num_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "delete", "I", "merge", "II", "remove", "include", "IIZ", "CZ", "LOrgApacheRegexpRECompiler;" };
  static const J2ObjcClassInfo _OrgApacheRegexpRECompiler_RERange = { "RERange", "org.apache.regexp", ptrTable, methods, fields, 7, 0x0, 6, 4, 8, -1, -1, -1, -1 };
  return &_OrgApacheRegexpRECompiler_RERange;
}

@end

void OrgApacheRegexpRECompiler_RERange_initWithOrgApacheRegexpRECompiler_(OrgApacheRegexpRECompiler_RERange *self, OrgApacheRegexpRECompiler *outer$) {
  NSObject_init(self);
  self->size_ = 16;
  self->minRange_ = [IOSIntArray newArrayWithLength:self->size_];
  self->maxRange_ = [IOSIntArray newArrayWithLength:self->size_];
  self->num_ = 0;
}

OrgApacheRegexpRECompiler_RERange *new_OrgApacheRegexpRECompiler_RERange_initWithOrgApacheRegexpRECompiler_(OrgApacheRegexpRECompiler *outer$) {
  J2OBJC_NEW_IMPL(OrgApacheRegexpRECompiler_RERange, initWithOrgApacheRegexpRECompiler_, outer$)
}

OrgApacheRegexpRECompiler_RERange *create_OrgApacheRegexpRECompiler_RERange_initWithOrgApacheRegexpRECompiler_(OrgApacheRegexpRECompiler *outer$) {
  J2OBJC_CREATE_IMPL(OrgApacheRegexpRECompiler_RERange, initWithOrgApacheRegexpRECompiler_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheRegexpRECompiler_RERange)
